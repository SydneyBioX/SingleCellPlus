<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />


<meta name="author" content="Sydney Precision Bioinformatics Group" />

<meta name="date" content="2019-06-18" />

<title>Downstream analysis</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/paper.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<link href="site_libs/highlightjs-9.12.0/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>




<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 64px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 69px;
  margin-top: -69px;
}
.section h2 {
  padding-top: 69px;
  margin-top: -69px;
}
.section h3 {
  padding-top: 69px;
  margin-top: -69px;
}
.section h4 {
  padding-top: 69px;
  margin-top: -69px;
}
.section h5 {
  padding-top: 69px;
  margin-top: -69px;
}
.section h6 {
  padding-top: 69px;
  margin-top: -69px;
}
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #ffffff;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>
<script>
$(document).ready(function () {
  window.initializeCodeFolding("show" === "show");
});
</script>



<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_').toLowerCase();
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}


.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">SingleCellPlus - HKU Workshop</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li>
  <a href="qc.html">QC Process</a>
</li>
<li>
  <a href="scMerge.html">scMerge</a>
</li>
<li>
  <a href="downstream.html">Downstream Analysis</a>
</li>
<li>
  <a href="acknowledgement.html">Acknowledgement</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">

<div class="btn-group pull-right">
<button type="button" class="btn btn-default btn-xs dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu" style="min-width: 50px;">
<li><a id="rmd-show-all-code" href="#">Show All Code</a></li>
<li><a id="rmd-hide-all-code" href="#">Hide All Code</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Downstream analysis</h1>
<h4 class="author">Sydney Precision Bioinformatics Group</h4>
<h4 class="date">18 June 2019</h4>

</div>


<div id="introduction" class="section level1">
<h1><span class="header-section-number">1</span> Introduction</h1>
<p>We have now preprocessed and merged our single cell data. The next step is to analyse the data for cell type identification, identification of marker genes and <em>et cetera</em>. We will focus on some simple steps of downstream analysis for single cell RNA-sequencing (scRNA-seq) data as shown below.</p>
<ol style="list-style-type: decimal">
<li><a href="#q1">What are the cell types present in the dataset?</a></li>
<li><a href="#q2">What are these cell clusters?</a></li>
<li><a href="#q3">For a gene of interest, how can I visualise the gene expression distribution?</a></li>
<li><a href="#q4">What are the cell type composition in the data?</a></li>
</ol>
<p>We will be using some of the functions we developed in our <code>scdney</code> package. You may visit our package website for the vignette and further details about <a href="https://sydneybiox.github.io/scdney/"><code>scdney</code></a>.</p>
<!-- ## Loading packages -->
<!-- ```{r load downstream pkg,  warning=FALSE, message=FALSE} -->
<!-- suppressPackageStartupMessages({ -->
<!--   library(SingleCellExperiment) -->
<!--   library(SummarizedExperiment) -->
<!--   library(dplyr) -->
<!--   library(edgeR) -->
<!--   library(scdney) -->
<!--   library(mclust) -->
<!--   library(Rtsne) -->
<!--   library(parallel) -->
<!--   library(cluster) -->
<!--   library(ggplot2) -->
<!--   library(MAST) -->
<!--   library(viridis) -->
<!--   library(ggpubr) -->
<!--   library(plyr) -->
<!--   library(monocle) -->
<!-- }) -->
<!-- theme_set(theme_classic(16)) -->
<!-- ``` -->
<!-- ## Loading data  -->
<!-- In the scMerge publication, we have merged [four mouse liver datasets](https://sydneybiox.github.io/scMerge/articles/case_study/Mouse_Liver_Data.html) together. This data is a bit too large for us to work with in this workshop, hence, we will take the merged data with all four datasets and subset ourselves to only the Su and Yang datasets. Some processings were performed in this data compare to the previous section, namely, the Megakaryocyte, Erythrocyte cells from the previous section are labelled as Hematopoietic cells in this section.  -->
<!-- ```{r} -->
<!-- sce_scMerge = readRDS("data/liver_scMerge.rds") -->
<!-- ## We will subset Su et al. and Yang et al. datasets. -->
<!-- ids = colData(sce_scMerge)$batch %in% c("GSE87795", "GSE90047") -->
<!-- subset_data = sce_scMerge[,ids] -->
<!-- lab = colData(subset_data)$cellTypes -->
<!-- nCs = length(table(lab)) -->
<!-- mat = SummarizedExperiment::assay(subset_data, "scMerge") -->
<!-- ``` -->
<!-- ```{r, fig.width=12, fig.height=6, message=FALSE, echo = FALSE} -->
<!-- cell_data = colData(subset_data) %>%  -->
<!--   as.data.frame() %>%  -->
<!--   tibble::rownames_to_column("cell_name") %>%  -->
<!--   dplyr::mutate(stage = stringr::str_sub(cell_name, 1, 3)) %>%  -->
<!--   dplyr::group_by(cellTypes, stage, batch) %>% -->
<!--   dplyr::summarise(n = n()) %>%  -->
<!--   dplyr::ungroup() %>%  -->
<!--   tidyr::complete(cellTypes, stage, batch, fill = list(n = 0)) -->
<!-- cell_data %>%  -->
<!--   ggplot(aes(x = stage, y = cellTypes, fill = n, label = n)) + -->
<!--   geom_tile() + -->
<!--   geom_text() + -->
<!--   facet_wrap(~batch) + -->
<!--   scale_fill_distiller(palette = "Blues", direction = 1) + -->
<!--   labs(title = "Number of cells split by batch, celltypes and stage") -->
<!-- ``` -->
<!-- # Q1. What are the cell types present in the dataset? {#q1} -->
<!-- Typically, a single cell RNA-sequencing experiment does not come with labelled cell type information for individual cells. We will need to identify cell types of indivdual cells in our data with bioinformatics analysis.  -->
<!-- Before we identify the cell types in the dataset, we need to first identify how many distinct group of population we can find from our data. One common method to achieve this is a statistical technique called **clustering**. A clustering method will group similar samples (cells) together and partition samples that are different by comparing their feature information (gene expression).  -->
<!-- There are two components that ultimately determine the performance of a clustering method:  -->
<!-- + The **similarity metric** that determines if two cells are similar to each other, and -->
<!-- + The **algorithm** itself that uses the similarity metric to perform the grouping operations. -->
<!-- In our recent study, we found Pearson correlation to be the optimal similarity metric for comparing single cell RNA-seq data ( [*Kim et al., 2018*](https://academic.oup.com/bib/advance-article-abstract/doi/10.1093/bib/bby076/5077112?redirectedFrom=fulltext) ). Therefore in this workshop, we will utilise `scClust` in our `scdney` package, which implemented 2017 Nature methods clustering algorithm `SIMLR` with pearson correlation. -->
<!-- ## How many distinct group of population are there in my dataset? -->
<!-- Typical clustering methods (except for some methods like hierarchical clustering) require users to specify number of distinct groups (`k`) to cluster from your data. In the context of this data, we can think of `k` as the the number of cell types. -->
<!-- In an unsupervised setting, we do not know the exact number and therefore, in a practical setting, we should run clustering for various number of `k` and evaluate their clustering performance.  -->
<!-- **However**, due to the time limit of this workshop, we will only run the `scClust` clustering for `k = 6` as a demonstration and load a saved result with more values of `k` computed.  -->
<!-- ```{r, warning = FALSE, eval = FALSE} -->
<!-- ## For demonstration purpose, we will run k = 6 (which is actually the number of cell types in our dataset) -->
<!-- simlr_result_k6 = scClust(mat, 6, similarity = "pearson", method = "simlr", seed = 1, cores.ratio = 0, geneFilter = 0) -->
<!-- load("data/simlr.results.RData") -->
<!-- ``` -->
<!-- [Extension] If you are interested, this is how you can compute `data/simlr.results.RData` by yourself. -->
<!-- ```{r, eval = FALSE} -->
<!-- ## We will NOT run for various `k` to save time. Instead, we will load pre-computed results for `k` between 3 to 8 -->
<!-- ## This is an easy way to run `scClust` for k = 3, 4, 5, 6, 7, 8. -->
<!-- all_k = 3:8 -->
<!-- simlr_results = sapply(as.character(all_k), function(k) { -->
<!--   scClust(mat, as.numeric(k), similarity = "pearson", method = "simlr", seed = 1, cores.ratio = 0, geneFilter = 0) -->
<!-- }, USE.NAMES = TRUE, simplify = FALSE) -->
<!-- ``` -->
<!-- ```{r, include = FALSE} -->
<!-- ## To make the knitting faster, we will load the precomputed results. -->
<!-- load("data/simlr.results.RData") -->
<!-- simlr_result_k6 = simlr_results$`6` -->
<!-- ``` -->
<!-- ## How do we select optimal `k`? -->
<!-- If our `k` is optimal, we should expect that the each cluster are closely packed together and the distances within the clusters, within-cluster sum of squares (WSS) are expected to be small. Thus, we will select the `k` with a small total WSS (compact clusters). This is called the "elbow" method. -->
<!-- ```{r, fig.height=6, fig.width=8} -->
<!-- # Find total WSS from all cluster outputs -->
<!-- all_wss = sapply(simlr_results, function(result) { -->
<!--   sum(result$y$withinss) -->
<!-- }, USE.NAMES = TRUE, simplify = TRUE) -->
<!-- plot_data = data.frame( -->
<!--   k = as.integer(names(all_wss)), -->
<!--   total_wss = all_wss -->
<!-- ) -->
<!-- ggplot(plot_data,  -->
<!--        aes(x = k,  -->
<!--            y = total_wss)) + -->
<!--   geom_point(size = 3) + -->
<!--   stat_smooth(method = loess, col = "red",  -->
<!--               method.args = list(degree = 1), se = FALSE) + -->
<!--   labs(title = "Compare Total WSS for each k", -->
<!--        y = "Total WSS") -->
<!-- ``` -->
<!-- As shown in this plot, the graph begin to plateau from `k` = 5. We can estimate that k is around 5 or 6. We can further investigate using silhouette scores or other metrics but using our t-SNE plot (this may require a bit of practical experience) we will estimate `k` = 6.  -->
<!-- <h4> <span class="glyphicon glyphicon-education" aria-hidden="true"></span> Quick quiz </h4> -->
<!-- 1. We can determine `k` with compactness of the clusters. What other measure can we use to determine `k`? -->
<!-- 2. How would you determine optimal number of clusters for hierarchical clustering? -->
<!-- <!-- <i class="fi-lightbulb"></i> -->
<p>–&gt;</p>
<!-- <h4> <span class="fi-lightbulb" aria-hidden="true"></span></h4> -->
<!-- ## Effect of similarity metrics -->
<!-- For the purpose of demonstration, we would like to highlight the effect of similarity metric to your cluster output. We will first compute a t-SNE plot and then overlay that with  -->
<!--   + Clustering result using Pearson correlation -->
<!--   + Clustering result using Euclidean distance -->
<!--   + True cell type labels from the publications -->
<!-- ```{r} -->
<!-- ## To run scClust with euclidean distance, uncommnet the following lines. -->
<!-- ## simlr_result_eucl_k6 = scClust(mat, 6, similarity = "euclidean", method = "simlr", seed = 1, cores.ratio = 0, geneFilter = 0) -->
<!-- ## for convenience, we will load our pre-computed result -->
<!-- load("data/simlr_result_eucl_k6.RData") -->
<!-- ``` -->
<!-- ```{r, fig.width=10, fig.height=5} -->
<!-- # create tsne object -->
<!-- set.seed(123) -->
<!-- tsne_result = Rtsne(t(mat), check_duplicates = FALSE) -->
<!-- ################################################# -->
<!-- tmp_lab = as.numeric(factor(lab)) -->
<!-- pear_cluster = plyr::mapvalues( -->
<!--   simlr_result_k6$y$cluster, -->
<!--   from = c(1,2,3,4,5,6), -->
<!--   to = c(2,3,1,4,6,5) -->
<!-- ) -->
<!-- eucl_cluster = plyr::mapvalues( -->
<!--   simlr_result_eucl_k6$y$cluster, -->
<!--   from = c(1,2,3,4,5,6), -->
<!--   to = c(6,2,4,3,1,5) -->
<!-- ) -->
<!-- ################################################# -->
<!-- plot_data = data.frame( -->
<!--   tsne1 = rep(tsne_result$Y[,1], 3), -->
<!--   tsne2 = rep(tsne_result$Y[,2], 3), -->
<!--   cluster = factor(c(tmp_lab, pear_cluster, eucl_cluster)), -->
<!--   label = rep(c("Truth", "Pearson", "Euclidean"), each = length(lab))) -->
<!-- ggplot(plot_data, aes(x = tsne1, y = tsne2, colour = cluster)) + -->
<!--   geom_point(size = 2) + -->
<!--   labs(title = "t-SNE plot") + -->
<!--   facet_grid(~label) +  -->
<!--   theme(legend.position = "none") -->
<!-- ``` -->
<!-- ```{r, fig.width=10, fig.height=5} -->
<!-- plot_data2 = data.frame( -->
<!--   Truth = lab, -->
<!--   computed_cluster = as.factor(c(pear_cluster, eucl_cluster)), -->
<!--   label = rep(c("Pearson", "Euclidean"), each = length(lab)) -->
<!-- ) -->
<!-- plot_data2 %>%  -->
<!--   dplyr::group_by(Truth, computed_cluster, label) %>% -->
<!--   dplyr::summarise(n = n()) %>%  -->
<!--   dplyr::ungroup() %>%  -->
<!--   tidyr::complete(Truth, computed_cluster, label, fill = list(n = 0)) %>%  -->
<!--   ggplot(aes(x = computed_cluster,  -->
<!--              y = Truth, -->
<!--              fill = n, label = n)) +  -->
<!--   geom_tile() + -->
<!--   geom_text() + -->
<!--   facet_wrap(~label) + -->
<!--   scale_fill_distiller(palette = "Blues", direction = 1) + -->
<!--   labs(title = "") -->
<!-- ``` -->
<!-- <h4> <span class="glyphicon glyphicon-education" aria-hidden="true"></span> Quick quiz </h4>  -->
<!-- 1. From your observation of the above t-SNE plot, did our clustering method (with Pearson correlation) group cells well? -->
<!-- **[Optional]** We can evaluate the clustering performance using the cell type labels providede from the publications.  -->
<!-- ```{r, fig.height=5, fig.width=10} -->
<!-- # ARI -->
<!-- ari = c(mclust::adjustedRandIndex(lab, simlr_result_eucl_k6$y$cluster), -->
<!--         mclust::adjustedRandIndex(lab, simlr_result_k6$y$cluster)) -->
<!-- # NMI -->
<!-- nmi = c(igraph::compare(as.numeric(factor(lab)),  -->
<!--                         simlr_result_eucl_k6$y$cluster, method = "nmi"),  -->
<!--         igraph::compare(as.numeric(factor(lab)),  -->
<!--                         simlr_result_k6$y$cluster, method = "nmi")) -->
<!-- plot_data = data.frame( -->
<!--   dist = rep(c("Euclidean", "Pearson"), 2), -->
<!--   value = c(ari, nmi), -->
<!--   eval = rep(c("ARI", "NMI"), each = 2) -->
<!-- ) -->
<!-- ggplot(plot_data, aes(x = dist, y = value, fill = dist)) +  -->
<!--   geom_bar(stat="identity") +  -->
<!--   facet_grid(col = vars(eval)) + -->
<!--   labs(x = "Similarity metrics",  -->
<!--        y = "Evalution score",  -->
<!--        title = "Affect of similarity metrics in scRNA-seq data") + -->
<!--   theme(legend.position = "none") -->
<!-- ``` -->
<!-- # Q2. What are these cell clusters? {#q2} -->
<!-- Now that we have clustered all the cells to 6 distinct groups, we may want to find out what these clusters are, i.e. what cell types are there in my dataset? Thus, we may ask what defines a cell type?  -->
<!-- We can use **marker genes** to identify cell types.  -->
<!-- ## 2.1 What are the marker genes that distinguish the different cell types? -->
<!-- Here we provide a function that allow one to find differentially expressed gene between a cluster and the remaining clusters. The input of this function is the expression matrix and the cluster ID. The output is a list of marker genes and their associated p-values.   -->
<!-- Here we provide an example of using the `findmarker` function.   -->
<!-- To find out the marker genes in cluster 4, we type in `4` in the `findmarker` function. We then look at the top 10 genes ranked by p-value. We can then use `ggplot` to visualise the distribution of one of the genes across the dataset.   -->
<!-- ```{r, eval = FALSE} -->
<!-- marker_cluster4 = findMarker(mat = mat,  -->
<!--                              cluster = simlr_result_k6$y$cluster,  -->
<!--                              cluster_id = 4) -->
<!-- ``` -->
<!-- ```{r, include = FALSE} -->
<!-- marker_cluster4 = readRDS("data/marker_cluster4.rds") -->
<!-- ``` -->
<!-- ```{r} -->
<!-- marker_cluster4[1:10, ] -->
<!-- ``` -->
<!-- ```{r, message=FALSE, warning=FALSE} -->
<!-- tsne_plotdf = data.frame( -->
<!--   tsne1 = tsne_result$Y[, 1], -->
<!--   tsne2 = tsne_result$Y[, 2]) %>%  -->
<!--   dplyr::mutate( -->
<!--     cluster = as.factor(simlr_result_k6$y$cluster), -->
<!--     Gys2 = mat["Gys2", ]) -->
<!-- ggplot(data = tsne_plotdf, aes(x = tsne1, y = tsne2, colour = Gys2) ) + -->
<!--   geom_point(alpha = 0.5) + -->
<!--   scale_color_viridis() + -->
<!--   labs(col = "Gys2 expression", x = "tsne1", y = "tsne2") -->
<!-- ``` -->
<!-- <h4> <span class="glyphicon glyphicon-education" aria-hidden="true"></span> Quick quiz </h4>   -->
<!-- 1. What does the above t-SNE plot tell you?     -->
<!-- 1. Here we repeat the analysis as above, but for cluster 3. See if you can understand the output.     -->
<!-- ```{r} -->
<!-- marker_cluster3 = readRDS("data/marker_cluster3.rds") -->
<!-- ``` -->
<!-- ```{r, message=FALSE, warning=FALSE} -->
<!-- tsne_plotdf = tsne_plotdf %>%  -->
<!--   dplyr::mutate(Erich5 = mat["Erich5",]) -->
<!-- ggplot(data = tsne_plotdf,  -->
<!--        mapping = aes(x = tsne1, y = tsne2, colour = Erich5)) + -->
<!--   geom_point(alpha = 0.5) +  -->
<!--   scale_color_viridis() + -->
<!--   labs(col="Erich5 expression") -->
<!-- ```  -->
<!-- # Q3. For a gene of interest, how can I visualise the gene expression distribution? {#q3} -->
<!-- In Q2, we have identified some interesting marker genes from our dataset. If we have a gene that we know, and we want to identify the its expression pattern in our dataset, we can also visualise the distribution. For example, Hnf4a has been stated in literature as a marker gene for hepatoblast cell (citation).    -->
<!-- The figure on the left highlight cluster 4 and the figure on the right highlight the expression of Hnf4a.   -->
<!-- This suggests that cluster 4 could belong to hepatoblast cell.  -->
<!-- ```{r, fig.height=6, fig.width=12} -->
<!-- tsne_plotdf = tsne_plotdf %>%  -->
<!--   dplyr::mutate(Hnf4a = mat["Hnf4a",]) -->
<!-- fig1 = ggplot(data = tsne_plotdf,  -->
<!--               mapping = aes(x = tsne1, y = tsne2)) +  -->
<!--   geom_point(aes(color = ifelse(cluster == 4, 'Yellow', 'Purple')), alpha = 0.5) + -->
<!--   scale_colour_viridis_d() +  -->
<!--   labs(x = "",  -->
<!--        y = "",  -->
<!--        title = "Cluster 4") + -->
<!--   theme(legend.position = "none")  -->
<!-- fig2 = ggplot(data = tsne_plotdf,  -->
<!--               mapping = aes(x = tsne1, y = tsne2, colour = Hnf4a) ) + -->
<!--   geom_point(alpha = 0.5) + -->
<!--   scale_color_viridis() + -->
<!--   labs(x = "",  -->
<!--        y = "", -->
<!--        title = "Hnf4a expression pattern") -->
<!-- ggarrange(fig1,fig2, ncol= 2, nrow = 1) -->
<!-- ``` -->
<!-- <h4> <span class="glyphicon glyphicon-education" aria-hidden="true"></span> Quick quiz </h4>   -->
<!-- See if you can understand the output of the following code.   -->
<!-- ```{r, fig.height=6, fig.width=12} -->
<!-- tsne_plotdf = tsne_plotdf %>%  -->
<!--   dplyr::mutate(Epcam = mat["Epcam",]) -->
<!-- fig1 = ggplot(data = tsne_plotdf, mapping = aes(x = tsne1, y = tsne2) ) +  -->
<!--   geom_point(aes(color = ifelse(cluster == 3, 'Yellow', 'Purple')), alpha = 0.5) + -->
<!--   scale_colour_viridis_d() +  -->
<!--   labs(x = "",  -->
<!--        y = "",  -->
<!--        title = "Cluster 3") + -->
<!--   theme(legend.position = "none")  -->
<!-- fig2 = ggplot(data = tsne_plotdf,  -->
<!--                mapping = aes(x = tsne1, y = tsne2, colour = Epcam) ) + -->
<!--   geom_point(alpha=0.5) + -->
<!--   scale_color_viridis() + -->
<!--   labs(x = "",  -->
<!--        y = "", -->
<!--        title = "Epcam expression pattern") -->
<!-- ggarrange(fig1,fig2, ncol= 2, nrow = 1) -->
<!-- ``` -->
<!-- As you may have already noticed from above steps, unsupervised clustering methods alone are not perfect in capturing cell type information. Using this step iteratively, we need to refine our cell type information. -->
<!-- # Q4. What are the cell type composition in the data? {#q4} -->
<!-- **NOTE:** From this step, we will assume we have correctly refined our cell type information from above steps and we will use the cell type information provided in Su et. al. 2017 and Yang et. al. 2017.  -->
<!-- ## Cell type proportions -->
<!-- ```{r, fig.width = 10, fig.height=10} -->
<!-- plot_data = data.frame(table(lab)) %>%  -->
<!--   dplyr::mutate(lab = reorder(lab, Freq)) -->
<!-- ggplot(plot_data,  -->
<!--        aes(x = lab,  -->
<!--            y = Freq,  -->
<!--            fill = lab)) + -->
<!--   geom_bar(stat = "identity") + -->
<!--   labs(x = "Cell types",  -->
<!--        y = "Frequency",  -->
<!--        title = "Composition of cell types") + -->
<!--   theme(legend.position = "none") -->
<!-- ``` -->
<!-- We observe that hepatoblast/hepatocyte is the largest population. -->
<!-- # Extension: Any rare cell type? What is the most common cell type? -->
<!-- # Extension: Monocle -->
<!-- A popular question in scRNA-Seq analysis is if the gene expressions patterns changes over some time. -->
<!-- The `monocle` method is a well-established psuedo-time trajectory reconstruction method from [Trapnell et. al. (2014)](https://www.nature.com/articles/nbt.2859). You can learn more about the theoretical construction of `monocle` here. In terms of computations, `monocle` requires some psuedo-time modelling on each gene and then markers are selected to perform psuedo-time ordering.  -->
<!-- The code below construct psuedo-time trajectory for the Hepatoblast/Hepatocyte cells in the merged data.  -->
<!-- ```{r, message = FALSE, warning = FALSE} -->
<!-- ## Subsetting data to "hepatoblast/hepatocyte" -->
<!-- monocle_data = subset_data[,colData(subset_data)$cellTypes %in% c("hepatoblast/hepatocyte")] -->
<!-- ## Add a "stage" column to the colData of the monocle_data -->
<!-- colData(monocle_data)$stage = stringr::str_sub(colnames(monocle_data), 1, 3) -->
<!-- table(colData(monocle_data)$stage) -->
<!-- ## monocle needs a rowData (data about each gene) -->
<!-- rowData(monocle_data) = DataFrame(gene_short_name = rownames(monocle_data)) -->
<!-- monocle_data -->
<!-- ## moncole requires a `CellDataSet` object to run.  -->
<!-- ## You can convert monocle_data into a `CellDataSet` object using the scran package. -->
<!-- monocle_CellDataSet = scran::convertTo( -->
<!--   monocle_data, -->
<!--   type = "monocle", -->
<!--   assay.type = "scMerge", -->
<!--   col.fields = c("cellTypes", "stage", "batch"), -->
<!--   row.fields = c("gene_short_name")) %>% -->
<!--   estimateSizeFactors() -->
<!-- ## Performing differential gene test using "stage".  -->
<!-- diff_test_res = differentialGeneTest( -->
<!--   monocle_CellDataSet, fullModelFormulaStr = "~stage") -->
<!-- ## We will select the top genes to be used for clustering and  -->
<!-- ## calculate dispersion (variability) parameters before constructing the trajectory -->
<!-- ordering_genes = row.names(subset(diff_test_res, qval < 0.00001)) -->
<!-- length(ordering_genes) -->
<!-- monocle_CellDataSet = setOrderingFilter(monocle_CellDataSet, ordering_genes) -->
<!-- monocle_CellDataSet = estimateDispersions(monocle_CellDataSet) %>% suppressWarnings() -->
<!-- # plot_ordering_genes(monocle_CellDataSet) -->
<!-- ## Construcing the trajectory -->
<!-- monocle_CellDataSet = reduceDimension(monocle_CellDataSet,  -->
<!--                                       max_components = 2, -->
<!--                                       method = 'DDRTree') -->
<!-- monocle_CellDataSet = orderCells(monocle_CellDataSet) -->
<!-- plot_cell_trajectory(monocle_CellDataSet, color_by = "stage") -->
<!-- # monocle::plot_cell_clusters(monocle_CellDataSet) -->
<!-- plot_genes_in_pseudotime(monocle_CellDataSet[c("Sarm1", "Gm38388"),], color_by = "stage") -->
<!-- ``` -->
</div>
<div id="sessioninfo" class="section level1">
<h1><span class="header-section-number">2</span> SessionInfo</h1>
<pre class="r"><code>sessionInfo()</code></pre>
<pre><code>## R version 3.6.0 (2017-01-27)
## Platform: x86_64-pc-linux-gnu (64-bit)
## Running under: Ubuntu 16.04.6 LTS
## 
## Matrix products: default
## BLAS:   /home/travis/R-bin/lib/R/lib/libRblas.so
## LAPACK: /home/travis/R-bin/lib/R/lib/libRlapack.so
## 
## locale:
##  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              
##  [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    
##  [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   
##  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 
##  [9] LC_ADDRESS=C               LC_TELEPHONE=C            
## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## loaded via a namespace (and not attached):
##  [1] compiler_3.6.0  magrittr_1.5    tools_3.6.0     htmltools_0.3.6
##  [5] yaml_2.2.0      Rcpp_1.0.1      stringi_1.4.3   rmarkdown_1.13 
##  [9] knitr_1.23      stringr_1.4.0   xfun_0.8        digest_0.6.20  
## [13] evaluate_0.14</code></pre>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
