---
title: "QC of single cell data"
author: "Sydney Precision Bioinformatics Group"
date: "18 June 2019"
output:
  html_document:
    code_folding: show
    fig_height: 10
    fig_width: 10
    toc: yes
    number_sections: true
    toc_depth: 3
    toc_float: yes
---

# Introduction

One of the first steps in single-cell RNA-seq analysis is to perform a quality check of the data you have sequenced in an experiment. This process is a necessary step before we proceed to data merging and other downstream data analyses. There are multiple quality control (QC) tools for sequencing data that we can use for both bulk and single-cell RNA-seq data. Here, we will look at some QC measures and generate a report on the quality of our single-cell data.

## Load in packages 

Load in packages required to generate the QC plots.

```{r load qc pkg, warning=FALSE, message=FALSE}
library(DropletUtils)
library(dplyr)
library(ggplot2)
library(scales)
library(ggpubr)
library(stringr)
library(forcats)

theme_set(theme_classic(16))
```

## The mouse liver dataset (Su et al. 2017)

For demonstration purpose, we will perform some QC checks on a single-cell mouse liver dataset generated by Su et al. (2017). This liver dataset contains 507 cells at seven developmental stages between embryonic day 11.5 and postnatal day 2.5. The cells were sequenced using the Fluidigm C1 platform and the reads are paired end. The file containing the raw count matrix is located in the `data` folder in the zip file you have downloaded. 

The dataset of read counts is stored in a `csv` file (which is simply an Excel file). We can load the data into R using the `read.csv()` function. Here, we will use two options: 

  + `header = TRUE` means that we will take the first row of the file as the column names. 
  + `row.names = 1` means that we will take the first column of the file as the row names.


```{r}
liver = read.csv(file = "data/GSE87795_counts.csv", 
                 header = TRUE,
                 row.names = 1)
```

First, let's check some basics of this data. This dataset contains 51918 rows and 507 columns. Each row corresponds to a gene, and each column corresponds to a cell. The first five rows and five columns of the dataset can be shown using `liver[1:5, 1:5]`. 

```{r}
dim(liver)
liver[1:5, 1:5]
```


Notice that the column names of this data contain information regarding the developmental stage of each cell when it was sequenced in the experiment. We can clean up this information using a short line of code. 

With some code, we can produce a frequency table of the number of cells at each developmental stage.

```{r}
stage = str_split(colnames(liver), "_") %>% 
  sapply("[[", 1)

table(stage)
```




## Quick Pre-processing of the Matrix

A simple way to make single-cell datasets manageable for analysis is to remove genes that are not expressed in any cells (i.e. genes that have zero counts across all cells). Since these genes do not containn any measurable signals, removing them does not affect the downstream analysis. In addition, a smaller dataset actually improves the performance and speed of most algorithms.

```{r}
liver = liver[rowSums(liver) != 0, ]
dim(liver)
```


Here, we first used `rowSums(liver)` to calculate the total counts for each gene across all cells. `rowSums(liver) != 0` then looks at if the total count is zero or not. And we will subset only those rows in the data (remember, rows of the data are genes) that are not purely zeroes. 

<h4> <span class="glyphicon glyphicon-education" aria-hidden="true"></span> Quick quiz </h4>    
  
How many genes do we have now?  


## Quality Control of Single Cell Data

### QC1: Waterfall Plot

The waterfall plot shows the log-count against the log-rank of each barcode. The barcodes are ranked based on the number of count each barcode has. The plots show two points of interest: 

  + **inflection point** is the point on the curve where the first derivative is minimised 
  + **knee point** is the point where the second derivative is minimised
  
  
These two points potentially indicate empty droplets (background barcodes). If the number of count in each cell drops rapidly for those cells beyond knee point, then it may suggest empty reads.  


```{r, fig.height=6, fig.width=6}
barcodeRank = DropletUtils::barcodeRanks(liver)
barcodeRank.data = as.data.frame(barcodeRank)
barcodeRank.points = data.frame(
  type = c("inflection", "knee"),
  value = c(barcodeRank@metadata$inflection, barcodeRank@metadata$knee))


ggplot(data = barcodeRank.data, aes(x = rank, y = total)) +
  geom_point() +
  geom_hline(data = barcodeRank.points, 
             aes(yintercept = value, 
                 colour = type), linetype = 2) +
  scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x),
                labels = trans_format("log10", math_format(10^.x))) +
  labs(title = "Waterfall plot of read counts (log)", 
       x = "Rank", 
       y = "Log counts")
```



<h4> <span class="glyphicon glyphicon-education" aria-hidden="true"></span> Quick quiz </h4>    
  
Based on the waterfall plot, should we filter out any cells? 

### QC2: Library Size

Next, we can evaluate the total library size, that is the collective read counts per cell. The library size may be used as an indicator of sequencing depth.


```{r, fig.height=4, fig.width=8}
library.plotdf.full = data.frame(
  cellName = colnames(liver),
  stage = stage, 
  library = colSums(liver),
  nGenes = colSums(liver != 0)
) 

library.plotdf = library.plotdf.full %>% 
 dplyr::filter(stage %in% c("E11.5", "E12.5", "E13.5"))


library.stage.mean = library.plotdf %>% 
  group_by(stage) %>% 
  dplyr::summarise(stage.library.mean = mean(library), 
                   stage.nGenes.exprs = mean(nGenes))


library.stage.mean

ggplot(library.plotdf, aes(x = library, colour = stage, fill = stage)) +
  geom_histogram(aes(y = ..density..), colour = "black", fill = "white", bins = 30) + 
  geom_density(alpha = 0.4) + 
  geom_vline(data = library.stage.mean, 
             aes(xintercept = stage.library.mean), 
             colour = "blue", linetype = "dashed", size = 1.5) +
  labs(title = "Histogram of library size", 
       x = "library size", 
       y = "density") + 
  facet_wrap(~ stage, ncol = 3) 
```




When we compare the distribution of librarzy size for all cells at three developmental stages, we can see that mean library size is lowest in E11.5 cells (mean=2838642) and highest in E13.5 cells (mean=3639297). E12.5 cells (mean=3094663) have a greater distribution of cells with few reads. Single cells with very few reads are likely to have failed to capture the transcriptome of a cell, and thus should be filtered.

## QC3: Number of Uniquely Expressed Genes

In addition to sequencing depth, we can also filter for cells that express genes with sufficiently good coverage of the transcriptome. This is to ensure that we capture cells with not only sufficient reads but also those that have reads that are relatively evenly distributed across the transcriptome. To this end, we measure the number of uniquely expressed genes in individual cells.

```{r, fig.height=6, fig.width=6, message=FALSE, warning=FALSE}
ggplot(library.plotdf, 
       aes(x = nGenes, colour = stage, fill = stage)) +
  geom_histogram(aes(y = ..density..), colour = "black", fill = "white", bins = 30) + 
  geom_density(alpha = 0.4) + 
  geom_vline(data = library.stage.mean,
             aes(xintercept = stage.nGenes.exprs), 
             colour = "blue", linetype = "dashed", size = 1.5) +
  labs(title = "Histogram of number of unique genes expressed", 
       x = "Number of unique genes expressed", 
       y = "density") + 
  facet_wrap(~ stage, ncol = 3) 
```

From above, we can see that most cells have between 9000-10,000 detected genes. This is roughly the amount expected for high-depth scRNA-seq; however, the expected value may vary between experimental protocols, sequencing depth, and cell type used. Note that, unlike library size, a "heavy tail" can be observed for each of the distribution, indicating an unequal detection of genes across populations. Filtering out cells with low number of genes identified is another way to improve the quality of the dataset.




### QC4: Mitochondrial Gene Expression

Unhealthy or dying cells are associated with high expression of mitochondrial genes, and thus the proportion of mitochondrial expression is commonly used as a quality metric.

```{r, message = FALSE}
mito.genes <- c("ENSMUSG00000064336", "ENSMUSG00000064337", "ENSMUSG00000064338", "ENSMUSG00000064339", "ENSMUSG00000064340", "ENSMUSG00000064341", "ENSMUSG00000064342", "ENSMUSG00000064343", "ENSMUSG00000064344", "ENSMUSG00000064345", "ENSMUSG00000064346", "ENSMUSG00000064347", "ENSMUSG00000064348", "ENSMUSG00000064349", "ENSMUSG00000064350", "ENSMUSG00000064351", "ENSMUSG00000064352", "ENSMUSG00000064353", "ENSMUSG00000064354", "ENSMUSG00000064355", "ENSMUSG00000064356", "ENSMUSG00000064357", "ENSMUSG00000064358", "ENSMUSG00000064359", "ENSMUSG00000064360", "ENSMUSG00000064361", "ENSMUSG00000065947", "ENSMUSG00000064363", "ENSMUSG00000064364", "ENSMUSG00000064365", "ENSMUSG00000064366", "ENSMUSG00000064367", "ENSMUSG00000064368", "ENSMUSG00000064369", "ENSMUSG00000064370", "ENSMUSG00000064371", "ENSMUSG00000064372", "ENSMUSG00000096105")


liver.mito = liver[mito.genes, ]

mito.plotdf =  data.frame(
  cellName = colnames(liver.mito),
  stage = stage, 
  mito.percent = colSums(liver.mito)/colSums(liver) * 100
) %>% dplyr::filter(stage %in% c("E11.5", "E12.5", "E13.5"))

mito.mean = mito.plotdf %>% 
  group_by(stage) %>% 
  dplyr::summarise(mean.mito.percent = mean(mito.percent))

mito.mean


g1 = ggplot(mito.plotdf, 
       aes(x = mito.percent, colour = stage, fill = stage)) +
  geom_histogram(aes(y = ..density..), colour = "black", fill = "white", bins = 30) + 
  geom_density(alpha = 0.4) + 
  geom_vline(data = mito.mean,
             aes(xintercept = mean.mito.percent), 
             colour = "blue", linetype = "dashed", size = 1.5) +
  labs(x = "mitochondrial percentage", 
       y = "density") + 
  scale_x_continuous(limits = c(0, 15)) +
  facet_wrap(~ stage, nrow = 3) 


g2 = ggplot(mito.plotdf, 
            aes(x = stage, 
                y = mito.percent, 
                fill = stage)) +
  geom_violin(alpha = 0.8, draw_quantiles = 0.5) + 
  labs(y = "mitochondrial percentage")

ggpubr::ggarrange(g1, g2, ncol=  2, common.legend = TRUE, legend = "right")
```


Filtering cells with greater than 10% of mitochondrial gene expression would remove cells that have abnormally high mitochondrial gene expression.  

<h4> <span class="glyphicon glyphicon-education" aria-hidden="true"></span> Quick quiz </h4>    
  
1. Based on the figure above, would you say most cells are unhealthy or healthy?   
2. How does the percentage of mitochondrial gene expression change over time point ?   


## QC5: Contribution by Top 50 Expressed Genes

As well as the above metrics, it is often instructive to know the proportions of the reads consumed by the top 50 expressed genes. Moreover, an assessment of the top gene list before and after filtering can give you a good indication of whether the filtering has been successful, as the top genes are often occupied by mitochondrial genes from unhealthy cells. 


```{r,  fig.height=12, fig.width=8}
liver.percent = sweep(liver, 2, STATS = colSums(liver), FUN = "/") * 100

liver.percent %>% colSums %>% head

liver.percent.split = split.data.frame(x = t(liver.percent), f = stage) %>% lapply(t)

liver.percent.split.rowMeans = liver.percent.split %>% lapply(rowMeans)


e115.top50 = liver.percent.split.rowMeans$E11.5 %>% sort(decreasing = TRUE) %>% head(50) %>% names
e115.top50

e115.liver.percent = liver.percent[e115.top50, stage == "E11.5"] %>% 
  as.matrix %>% 
  reshape2::melt(varnames = c("gene.name", "cell.name")) %>% 
  dplyr::mutate(gene.name = fct_reorder(gene.name, value, mean))

e115.liver.percent %>% 
  ggplot(aes(x = gene.name, y = value, colour = gene.name)) +
  geom_violin() +
  geom_jitter(alpha = 0.2) +
  coord_flip() +
  labs(x = "percent of library", 
       y = "genes") +
  theme(legend.position = "none")
```



<!-- ```{r} -->
<!-- liver.percent.melt = liver.percent %>% -->
<!--   as.matrix %>%  -->
<!--   reshape2::melt(varnames = c("gene.name", "cell.name"), value.name = "percent") %>%  -->
<!--   dplyr::mutate(stage = str_split(cell.name, "_") %>% sapply("[[", 1))  -->

<!-- e115.percent = liver.percent.melt %>%  -->
<!--   dplyr::filter(stage == "E11.5") %>%  -->
<!--   dplyr::mutate(gene.name = forcats::fct_reorder(gene.name, percent, mean, .desc = TRUE)) %>%  -->
<!--   dplyr::filter(as.integer(gene.name) <= 50) -->


<!-- e115.percent %>%  -->
<!--   ggplot(aes(x = fct_rev(gene.name), y = percent, colour = gene.name)) + -->
<!--   geom_violin() + -->
<!--   geom_jitter(alpha = 0.2) + -->
<!--   coord_flip() + -->
<!--   labs(x = "percent",  -->
<!--        y = "") -->
<!--   theme(legend.position = "none") -->
<!-- ``` -->

The plot above show that there are four spike-in genes within the top 50 genes. The presence of multiple spike-ins at the top of the list suggests that the concentration of spike-ins added to the experiment may need to be optimized for subsequent experiments. Overall, the relatively flat distributions indicate good coverage of the transcriptome.



### Filtering 
Here we will give a demonstration of how you can remove some of the cells from the dataset.  
Recall in the waterfall plot, we have identified 2 outlier cells with low read counts. Here, we will illustrate how you can remove these two cells from the dataset.  

In the code provided below, originally there was 507 cells in the dataset, the 2 outlier cells would have rank 506 and 507 (largest rank means least number of reads). We look at which cells has rank >= 506 and use the row index to subset the dataset. The which() function gives you the row index and the minus sign '-' tells R to remove the given row index from the dataset.  

Finally we should check that the dimension of the dataset is correct after filtering. 
```{r}
liver_new <- liver[, barcodeRank.data$rank <= 506]
dim(liver_new)
```

[Extension]. Try removing the cells with abnormally high mitochondrial gene expression


# Session Info
```{r}
Sys.time()
sessionInfo()
```

