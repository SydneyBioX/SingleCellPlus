---
title: "QC of single cell data"
author: "Sydney Precision Bioinformatics Group"
date: "03/05/2019"
output:
  html_document:
    code_folding: hide
    number_sections: yes
    toc: yes
    fig_height: 8
    fig_width: 8
    toc_float:
      collapsed: true
      smooth_scroll: false
---


As discussed in 3rd May 2019, Yue Cao and Hani Kim will be jointly working on this part of the workshop. 

However, the raw data will be prepared by Yingxin. 


## Introduction
One of the first things you need to do when you have obtained single-cell RNA-seq data is to perform a quality check of the reads you have sequenced. This process is part of cleaning our expression matrix in preparation for downstream data analysis. There are multiple quality control (QC) tools for sequencing data that can be used for both bulk and single-cell RNA-seq data. Here, we will work on performing various QCs and generate a report on the read quality of our data. 

### Load in packages 
First we will load in a package that is required for producing one of the quality control plots.  
```{r warning=FALSE, message=FALSE}
library(DropletUtils) #Droplet Utils is needed to plot the waterfall plot
```

### The Dataset
To illustrate cell QC, today we will be performing our analysis using single cell mouse liver dataset generated by Su et al. (2017). This liver dataset contains 507 cells at seven developmental stages between embryonic day 11.5 and postnatal day 2.5.  The cells were sequenced using the Fluidigm C1 platform and the reads are paired end. The file containing the raw count matrix is located in the ‘X’ folder in your working directory. 

As the dataset is stored in a csv file, we can load the data into R using the read.csv() function.  
```{r}
scLiver <- read.csv("data/GSE87795_counts.csv")
```

We can use head() to inspect a small portion of the expression matrix.
```{r fig.height=6, fig.width=6}
head(scLiver[,1:5])
dim(scLiver)
```
This dataset contains 51918 rows and 507 columns. Each row corresponds to a gene, and each column corresponds to a individual cell sequenced.

With some code, we can produce a frequencyu table of the number of cells in each developmental stage.
```{r}
stage <- unlist(lapply(strsplit(colnames(scLiver), "_"), "[[", 1))
table(stage)
```

Note that the first column of the matrix records the gene ID. We can assign this gene ID column as the column name of the count matrix and then remove this column from the count matrix.
```{r}
geneID <- scLiver[,1]
rownames(scLiver) <- geneID
scLiver <- scLiver[,-1]
head(scLiver[,1:5])
```
Now that the count matrix only contains numerical values (the gene count), this makes subsequent analyses easier. 


### Quick Pre-processing of the Matrix
A simple way to make single cell datasets manageable for downstream analysis is to remove genes that are not expressed in any cells. Removing these genes does not affect the outcome of downstream analyses such as clustering yet help to improve computational speed dramatically. 
```{r}
noexpress <- which(rowSums(scLiver) == 0)  #we use which() function to find out which genes are not expressed in any cells. These would be the genes with row sum equal to 0.   
scLiver <- scLiver[-noexpress, ] #the minus sign indicate we are removing these rows from the data matrix (ie, removing these genes from the data matrix)

dim(scLiver)
```
Before filtering,  dataset contains 51918 genes,  now it contains 37766 genes.  



## Quality Control of Single Cell Data
There are a number of ways to assess the quality of our datasets. 

### QC1: Waterfall Plot
```{r fig.height=6, fig.width=6}
br.out <- barcodeRanks(scLiver)
plot(br.out$rank, br.out$total, log="xy", xlab="Rank", ylab="Total", col="royalblue")
o <- order(br.out$rank)
lines(br.out$rank[o], br.out$fitted[o], col="red")
abline(h=br.out$knee, col="dodgerblue", lty=2)
abline(h=br.out$inflection, col="forestgreen", lty=2)
legend("bottomleft", lty=2, col=c("dodgerblue", "forestgreen"),
        legend=c("knee", "inflection"))
```

### QC2: Library Size
Next, we can evaluate the total library size, that is the collective count of reads per cell, which provide an indication of sequencing depth.
```{r fig.height=6, fig.width=6}
options(scipen=999)
par(mfrow=c(1,2))
hist(colSums(scLiver[,grepl("E11.5",colnames(scLiver))])/1e3, breaks = 20, main = "E11.5", ylab = "number of cells", xlab = "library size (thousands)", col="gray")
hist(colSums(scLiver[,grepl("E13.5",colnames(scLiver))])/1e3, breaks = 20, main = "E13.5", ylab = "number of cells", xlab = "library size (thousands)", col="gray")
```

### QC3: Number of Uniquely Expressed Genes
The number of uniquely expressed genes in individual cells
```{r fig.height=6, fig.width=6}
par(mfrow=c(1,2))
hist(colSums(scLiver[, grepl("E11.5",colnames(scLiver))]!=0), breaks = 20, main = "E11.5", ylab = "number of cells", xlab = "number of expressed genes", col="gray")
hist(colSums(scLiver[, grepl("E13.5",colnames(scLiver))]!=0), breaks = 20, main = "E13.5", ylab = "number of cells", xlab = "number of expressed genes", col="gray")
```

The two parameters are generally correlated. The poorer the sequencing depth of the dataset, the fewer the number of genes detected per cell.
```{r}

```

### QC4: Mitochondrial Gene Expression
There are approximately X number of mitochondrial genes in humans. The expression of mitochondrial genes is a common measure of quality control, as the level of mitochondrial gene expression can often indicate whether a cell is healthy or not. Calculating the percentage of total count contributed by the collective count of mitochondrial genes provides a rough estimate of cell quality. Generally, cells have ~10%... However, this value would  
```{r}

```

### QC5: ERCC
```{r}

```

### QC6: Contribution by Top 50 Expressed Genes
```{r}

```

