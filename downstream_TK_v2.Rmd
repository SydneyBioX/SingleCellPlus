---
title: "Downstream analysis"
author: "Sydney Precision Bioinformatics Group"
date: "03/05/2019"
output:
  html_document:
    code_folding: hide
    fig_height: 12
    fig_width: 12
    toc: yes
    # number_sections: true
    toc_depth: 3
    toc_float: yes
editor_options: 
  chunk_output_type: console
---

# Introduction

We have now preprocessed and merged our single cell data. The next step is to analyse the data for cell type identification, identification of marker genes and *et cetera*. We will focus on some simple steps of downstream analysis for single cell RNA-sequencing (scRNA-seq) data as shown below.

1. [What are the cell types present in the dataset?](#q1)
2. [What are these cell clusters?](#q2)
3. [For a gene of interest, how can I visualise the gene expression distribution?](#q3)
4. [What are the cell type composition in the data?](#q4)


```{r}
# This section is to install package that will be required to proceed with this section of the workshop.

# If you do not have "devtools" installed, uncomment the following line and run on your console
# install.packages("devtools")

# devtools::install_github("SydneyBioX/scdney")
```

We will be using some of the functions we developed in our  `scdney` package. You may visit our package website for the vignette and further details about [`scdney`](https://sydneybiox.github.io/scdney/).

```{r, echo = FALSE, warning=FALSE}

suppressPackageStartupMessages({
  library(SingleCellExperiment)
  library(SummarizedExperiment)
  library(dplyr)
  library(edgeR)
  library(scdney)
  library(mclust)
  library(Rtsne)
  library(parallel)
  library(cluster)
  library(ggplot2)
  library(MAST)
  library(viridis)
  library(ggpubr)
  library(plyr)
})
# sce_scMerge = readRDS(file = "data/liver_scMerge_2019_May_29.RDS")
# sce_scMerge = readRDS("~/Dropbox (Sydney Uni)/workdir/singleCell/workshop/data/liver_scMerge.rds")

sce_scMerge = readRDS(paste(getwd(), "/data/liver_scMerge.rds",sep = ""))
```

```{r}
# We will subset Su et al. and Yang et al. datasets.
ids = which(colData(sce_scMerge)$batch %in% c("GSE87795", "GSE90047"))

lab = colData(sce_scMerge)$cellTypes[ids]

nCs = length(table(lab))

mat = SummarizedExperiment::assay(sce_scMerge, "scMerge")[,ids]
```


<a id="q1" />

# Q1. What are the cell types present in the dataset?

The data from single cell RNA-sequencing experiment does not provide cell type information for individual cells. We need to identify cell types of indivdual cells in our data with bioinformatics analysis. 

Before we identify the cell types in the dataset, we need to first identify how many distinct group of population we can find from our data. One common method to achieve this is by clustering. Clustering is a type of machine learning technique to group similar samples (cell) to the same group and partition samples that are different by comparing their feature information (gene expression). 

To optimise clustering method, algorithm and similarity metric are two key components that affects clustering performance. 

In our recent study, we found pearson correlation to be optimal similarity metric for comparing single cell RNA-seq data ( [*Kim et al., 2018*](https://academic.oup.com/bib/advance-article-abstract/doi/10.1093/bib/bby076/5077112?redirectedFrom=fulltext) ). Therefore in this workshop, we will utilise `scClust` in our `scdney` package, which implemented 2017 Nature methods clustering algorithm `SIMLR` with pearson correlation.


## How many distinct group of population are there in my dataset?

Typical clustering methods (except for some methods like hierarchical clustering) require users to specify number of distinct groups (`k`) to cluster from your data. In an unsupervised setting, we do not know the exact number and therefore we will run clustering for various number of `k`.

```{r, warning=FALSE}
# We will not run for various `k` to save time. Instead, we will load pre-computed results for `k` between 3 to 8

# This is an easy way to run `scClust` for k = (3,4,5,6,7,8).
# all_k = 3:8
# simlr_results = sapply(as.character(all_k), function(k) {
#   scClust(mat, as.numeric(k), similarity = "pearson", method = "simlr", seed = 1, cores.ratio = 0, geneFilter = 0)
# }, USE.NAMES = TRUE, simplify = FALSE)

# For demonstration purpose, we will run k = 6 (which is actually the number of cell types in our dataset)
simlr_result_k6 = scClust(mat, 6, similarity = "pearson", method = "simlr", seed = 1, cores.ratio = 0, geneFilter = 0)

# load("~/Dropbox (Sydney Uni)/workdir/singleCell/workshop/data/simlr_result_k6.RData")

load(paste(getwd(), "/data/simlr.results.RData", sep = ""))

```




## How do we select optimal `k`?

If our `k` is correct, we expect that the each clusters are closely packed together and the distance between the clusters, within-cluster sum of squares (WSS) are expected to be small. Thus, we will select the `k` with a small total WSS (compact clusters). This is called the "Elbow" method.

```{r}
# Find total WSS from all cluster outputs
all_wss = sapply(simlr_results, function(result) {
  sum(result$y$withinss)
}, USE.NAMES = TRUE, simplify = TRUE)

plt.dat = data.frame(
  k = names(all_wss),
  total_wss = all_wss
)

ggplot(plt.dat, aes(x = as.numeric(as.character(k)), y = total_wss)) +
  geom_point(size = 3) +
  stat_smooth(method = loess, col = "red", method.args = list(degree = 1)) +
  ylab("Total WSS") +
  ggtitle("Compare Total WSS for each 'k'")

```



As shown in this plot, the graph begin to plateau from `k` = 5. We can estimate that k is around 5 or 6. We can further investigate using silhouette scores or other metrics but using our t-SNE plot (and with a little cheating) we will estimate `k` = 6. 

<h4> <span class="glyphicon glyphicon-education" aria-hidden="true"></span> Quick quiz </h4>

 1. We can determine `k` with compactness of the clusters. What other measure can we use to determine `k`?
 2. How would you determine optimal number of clusters for hierarchical clustering?

<!-- <i class="fi-lightbulb"></i> -->

<h4> <span class="fi-lightbulb" aria-hidden="true"></span></h4>

For the purpose of demonstration, we would like to highlight the effect of similarity metric to your cluster output.

```{r}
# To run scClust with euclidean distance, uncommnet the following lines.
# simlr_result_eucl_k6 = scClust(mat, 6, similarity = "euclidean", method = "simlr", seed = 1, cores.ratio = 0, geneFilter = 0)

# for convenience, we will load our pre-computed result
load(paste(getwd(), "/data/simlr_result_eucl_k6.RData", sep = ""))
```


```{r, fig.width=10, fig.height=5}
# create tsne object
set.seed(123)
tsne_result = Rtsne(t(mat), check_duplicates = FALSE)

#################################################
tmp_lab = as.numeric(factor(lab))
pear_cluster = mapvalues(
  simlr_result_k6$y$cluster,
  from = c(1,2,3,4,5,6),
  to = c(2,3,1,4,6,5)
)
eucl_cluster = mapvalues(
  simlr_result_eucl_k6$y$cluster,
  from = c(1,2,3,4,5,6),
  to = c(6,2,4,3,1,5)
)
#################################################

plt.dat = data.frame(
  tsne1 = rep(tsne_result$Y[,1], 3),
  tsne2 = rep(tsne_result$Y[,2], 3),
  cluster = factor(c(tmp_lab, pear_cluster, eucl_cluster)),
  label = factor(c(rep("Truth", length(lab)), rep("Pearson", length(lab)), rep("Euclidean", length(lab))), levels = c("Truth", "Pearson", "Euclidean"))
)

ggplot(plt.dat, aes(x = tsne1, y = tsne2, colour = cluster, colors)) +
  geom_point(size = 2) +
  ggtitle("t-SNE plot") +
  facet_grid(cols=vars(label)) + 
  theme(legend.position = "none")
  
```


<h4> <span class="glyphicon glyphicon-education" aria-hidden="true"></span> Quick quiz </h4> 

 1. From your observation of the above t-SNE plot, did our clustering method (with Pearson correlation) group cells well?
 

**[Optional]** We can evaluate the clustering performance using our ground truth.

```{r, fig.height=5, fig.width=10}
# ARI
ari = c(mclust::adjustedRandIndex(lab, simlr_result_eucl_k6$y$cluster), mclust::adjustedRandIndex(lab, simlr_result_k6$y$cluster))

# NMI
nmi = c(igraph::compare(as.numeric(factor(lab)), simlr_result_eucl_k6$y$cluster, method = "nmi"), igraph::compare(as.numeric(factor(lab)), simlr_result_k6$y$cluster, method = "nmi"))

plt.dat = data.frame(
  dist = rep(c("Euclidean", "Pearson"), 2),
  value = c(ari, nmi),
  eval = rep(c("ARI", "NMI"), each = 2)
)

ggplot(plt.dat, aes(x = dist, y = value, fill = dist)) + 
  geom_bar(stat="identity") + 
  facet_grid(col = vars(eval)) +
  labs(x = "Similarity metrics", y = "Evalution score", title = "Affect of similarity metrics in scRNA-seq data")
```



<a id="q2" />

# Q2. What are these cell clusters? 

We have grouped all the cells to 6 distinct groups. We now want to identify what these groups are, i.e. what cell types are there in my dataset? Thus, what defines a cell type? 

We can use marker genes to identify cell types. 

## 2.1 What are the marker genes that distinguish the different cell types?

Here we provide a function that allow one to find differentially expressed gene between a cluster and the remaining clusters. The input of this function is the cluster id. The output is a list of gene and its associated p - value.  

```{r}
# This function is specific for scClust ouptut object that ran with "SIMLR"
findmarker <- function(mat, scClust_obj, cluster_id){

  #group 1 is the cluster of interest
  group1 = which(scClust_obj$y$cluster == cluster_id)  
  group1 = colnames(mat)[group1]  #find out which cell belongs to group 1
  
  group_label <- ifelse(colnames(mat) %in% group1, "group1", "group2")  #if the cell is in group 1 ,create a label called group 1, else create a label called group 2
  
  #create a dataframe , with cell name and the group that this cell belongs to 
  group_label <- data.frame(group_label, colnames(mat))
  rownames(group_label) <- group_label[,2]
  colnames(group_label) <- c("group","wellKey")
  #MAST requires a wellkey (which essentially is the name of the cell)
  
  
  #create a dataframe, with gene name 
  gene_label <- data.frame(rownames( mat))
  colnames(gene_label) <- "primerid"
  rownames(gene_label) <- gene_label[, 1]
  #MAST requires a primerid (which essentially is the gene name)
  
   #create a MAST object, with the group id of each cell and the gene name 
  sca <- MAST::FromMatrix(
      exprsArray = mat,
      cData = group_label,
      fData = gene_label
  )

  #this is the differential expression model (called a hurdle model)
  #(see https://www.bioconductor.org/packages/release/bioc/vignettes/MAST/inst/doc/MAITAnalysis.html#4_differential_expression_using_a_hurdle_model)
  zlmCond <- MAST::zlm(~group, sca) 
  summaryCond <- summary(object = zlmCond, doLRT = 'groupgroup2') 
  
  #now extract the information 
  summaryDT <- data.frame(summaryCond$datatable)
  return_val <-data.frame(summaryDT[summaryDT[, "component"] == "H", 1], summaryDT[summaryDT[, "component"] == "H", 4])
  #We select the "H" rows, the "H" means we want hurdle P values
  #extract both the gene name and the P value associated with this gene
  colnames(return_val) <- c("gene", "P_value")
  
  #order by the p value , from the most significant 
  return_val <- return_val[order(return_val$P_value), ]
  
  return (return_val)

}
```


Here we provide an example of using the findmarker gene function.  
To find out the marker gene in cluster 4, we type in 4 in the findmarker function. We then look at the top 10 genes ranked by p-value. We can then use ggplot to visualise the distribution of one of the genes across the dataset.  

```{r, cache= TRUE, message=FALSE, warning=FALSE}
df<- data.frame(tsne_result$Y)
df<- cbind(df, as.factor(simlr_result_k6$y$cluster) )

df = df %>%
  dplyr::rename(
    tsne1 = X1,
    tsne2 = X2,
    cluster = `as.factor(simlr_result_k6$y$cluster)`
  )


marker <- findmarker(mat, simlr_result_k6, 4)
marker[1:10,]

index <- which(rownames(sce_scMerge[,ids]) == "Gys2")
# df_Gys2 <- cbind(df, mat[index,] )
df_Gys2 = df
df_Gys2$Gys2 = mat[index,]

ggplot(data =df_Gys2, mapping = aes(x=tsne1, y = tsne2, colour = Gys2) ) +
  geom_point(alpha=0.5) +
  scale_color_viridis() +
  theme_bw() +
  labs(col="Gys2 expression", x = "tsne1", y = "tsne2")
```

<h4> <span class="glyphicon glyphicon-education" aria-hidden="true"></span> Quick quiz </h4>

What does the above t-SNE plot tell you?    

<h4> <span class="glyphicon glyphicon-education" aria-hidden="true"></span> Quick quiz </h4>  

Here we repeat the analysis as above, but for cluster 3. See if you can understand the output.    

```{r, cache = TRUE, message=FALSE, warning=FALSE}
marker <- findmarker(mat, simlr_result_k6, 3)
marker[1:10,]

index <- which(rownames(sce_scMerge[,ids]) == "Erich5")
# df_erich<- cbind(df, mat[index,] )
df_erich <- df
df_erich$erich = mat[index,]

ggplot(data =df_erich, mapping = aes(x=tsne1, y = tsne2, colour = erich) ) +
  geom_point(alpha=0.5)+scale_color_viridis()+
  theme_bw()+
  labs(col="Erich5 expression")

``` 
 


<a id="q3" />

# Q3. For a gene of interest, how can I visualise the gene expression distribution? 


In Q2, we have identified some interesting marker genes from our dataset. If we have a gene that we know, and we want to identify the its expression pattern in our dataset, we can also visualise the distribution. For example, Hnf4a has been stated in literature as a marker gene for hepatoblast cell.   

The figure on the left highlight cluster 4 and the figure on the right highlight the expression of Hnf4a.  

This suggests that cluster 4 could belong to hepatoblast cell. 


```{r}
fig1 <- ggplot(data = df, mapping = aes(x=tsne1, y = tsne2) ) + 
  geom_point(aes(color = ifelse(cluster == 4, 'Yellow', 'Purple') ) ,alpha=0.4) + scale_colour_viridis_d() + 
  ggtitle("Cluster 4") +
  xlab("") + 
  ylab("") + 
  labs(colour = "") +
  theme(legend.title=element_blank()) +
  theme_bw()+ guides(color=FALSE) 

index <- which(rownames(sce_scMerge[,ids]) == "Hnf4a")
df_hnf4a <- df
df_hnf4a$hnf4a = mat[index,]

fig2 <- ggplot(data =df_hnf4a, mapping = aes(x=tsne1, y = tsne2, colour = hnf4a) ) +
  geom_point(alpha=0.5) +
  scale_color_viridis() +
  theme_bw()+labs(col="expression") +
  ggtitle("Hnf4a expression pattern")

ggarrange(fig1,fig2, ncol= 2, nrow = 1)
```

<h4> <span class="glyphicon glyphicon-education" aria-hidden="true"></span> Quick quiz </h4>  
 
See if you can understand the output of the following code.  


```{r}


fig1<- ggplot(data =df, mapping = aes(x=tsne1, y = tsne2) ) + 
  geom_point(aes(color = ifelse(cluster == 3, 'Yellow', 'Purple') ) ,alpha=0.4) +
  scale_colour_viridis_d() + 
  ggtitle("Cluster 3") +
  labs(colour = "")+
  theme(legend.title=element_blank())+
  theme_bw()+ 
  guides(color=FALSE)


index <- which(rownames(sce_scMerge[,ids]) == "Epcam")
df_epcam<- cbind(df, mat[index,] )

fig2 <- ggplot(data =df_epcam, mapping = aes(x=tsne1, y = tsne2, colour = `mat[index, ]`) ) +
  geom_point(alpha=0.5)+
  scale_color_viridis()+
  theme_bw()+
  labs(col="expression")+
  ggtitle("Epcam expression pattern")

ggarrange(fig1,fig2, ncol= 2, nrow = 1)


```


As you may have already noticed from above steps, unsupervised clustering methods alone are not perfect in capturing cell type information. Using this step iteratively, we need to refine our cell type information.

<a id="q4" />

# Q4. What are the cell type composition in the data?

**NOTE:** From this step, we will assume we have correctly refined our cell type information from above steps and we will use our "known" cell type information.

## Cell type proportions

```{r, fig.width = 7, fig.height=7}
plt.dat = data.frame(
  table(lab)
)

ggplot(plt.dat, aes(x = lab, y = Freq, fill = lab)) +
  geom_bar(stat = "identity") +
  labs(x = "Cell types", y = "Frequency", title = "Composition of cell types")
```

We observe that hepatoblast/hepatocyte is the largest population.


# [Extension]. Any rare cell type? What is the most common cell type?







# SessionInfo

```{r}
sessionInfo()
```